<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>pytorch-learn-00 | 闲庭杂记</title><meta name="author" content="Confetti-lxy"><meta name="copyright" content="Confetti-lxy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="pytorch学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="pytorch-learn-00">
<meta property="og:url" content="http://blog.confetti-lxy.com/2023/05/12/pytorch-learn-00/index.html">
<meta property="og:site_name" content="闲庭杂记">
<meta property="og:description" content="pytorch学习笔记">
<meta property="og:locale" content="zn_CN">
<meta property="og:image" content="http://blog.confetti-lxy.com/img/cover/cover-11.jpeg">
<meta property="article:published_time" content="2023-05-12T15:10:52.000Z">
<meta property="article:modified_time" content="2023-05-12T15:13:53.976Z">
<meta property="article:author" content="Confetti-lxy">
<meta property="article:tag" content="torch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.confetti-lxy.com/img/cover/cover-11.jpeg"><link rel="shortcut icon" href="/img/common/favicon.ico"><link rel="canonical" href="http://blog.confetti-lxy.com/2023/05/12/pytorch-learn-00/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pytorch-learn-00',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-12 23:13:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/common/avatar.png" onerror="onerror=null;src='/img/common/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/PL/PL-1.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="闲庭杂记"><span class="site-name">闲庭杂记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">pytorch-learn-00</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-12T15:10:52.000Z" title="Created 2023-05-12 23:10:52">2023-05-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-12T15:13:53.976Z" title="Updated 2023-05-12 23:13:53">2023-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pytorch/">pytorch</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>56min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="pytorch-learn-00"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="pytorch-fundamentals">00. PyTorch Fundamentals</h1>
<h2 id="what-is-pytorch">What is PyTorch?</h2>
<p><a target="_blank" rel="noopener" href="https://pytorch.org/">PyTorch</a> is an open source machine
learning and deep learning framework.</p>
<h2 id="what-can-pytorch-be-used-for">What can PyTorch be used for?</h2>
<p>PyTorch allows you to manipulate and process data and write machine
learning algorithms using Python code.</p>
<h2 id="who-uses-pytorch">Who uses PyTorch?</h2>
<p>Many of the worlds largest technology companies such as <a
target="_blank" rel="noopener" href="https://ai.facebook.com/blog/pytorch-builds-the-future-of-ai-and-machine-learning-at-facebook/">Meta
(Facebook)</a>, Tesla and Microsoft as well as artificial intelligence
research companies such as <a
target="_blank" rel="noopener" href="https://openai.com/blog/openai-pytorch/">OpenAI use PyTorch</a> to
power research and bring machine learning to their products.</p>
<figure>
<img
src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/00-pytorch-being-used-across-research-and-industry.png"
alt="pytorch being used across industry and research" />
<figcaption aria-hidden="true">pytorch being used across industry and
research</figcaption>
</figure>
<p>For example, Andrej Karpathy (head of AI at Tesla) has given several
talks (<a target="_blank" rel="noopener" href="https://youtu.be/oBklltKXtDE">PyTorch DevCon 2019</a>,
<a target="_blank" rel="noopener" href="https://youtu.be/j0z4FweCy4M?t=2904">Tesla AI Day 2021</a>)
about how Tesla use PyTorch to power their self-driving computer vision
models.</p>
<p>PyTorch is also used in other industries such as argiculture to <a
target="_blank" rel="noopener" href="https://medium.com/pytorch/ai-for-ag-production-machine-learning-for-agriculture-e8cfdb9849a1">power
computer vision on tractors</a>.</p>
<h2 id="why-use-pytorch">Why use PyTorch?</h2>
<p>Machine learning researchers love using PyTorch. And as of February
2022, PyTorch is the <a target="_blank" rel="noopener" href="https://paperswithcode.com/trends">most
used deep learning framework on Papers With Code</a>, a website for
tracking machine learning research papers and the code repositories
attached with them.</p>
<p>PyTorch also helps take care of many things such as GPU acceleration
(making your code run faster) behind the scenes.</p>
<p>So you can focus on manipulating data and writing algorithms and
PyTorch will make sure it runs fast.</p>
<p>And if companies such as Tesla and Meta (Facebook) use it to build
models they deploy to power hundreds of applications, drive thousands of
cars and deliver content to billions of people, it's clearly capable on
the development front too.</p>
<h2 id="what-were-going-to-cover-in-this-module">What we're going to
cover in this module</h2>
<p>This course is broken down into different sections (notebooks).</p>
<p>Each notebook covers important ideas and concepts within PyTorch.</p>
<p>Subsequent notebooks build upon knowledge from the previous one
(numbering starts at 00, 01, 02 and goes to whatever it ends up going
to).</p>
<p>This notebook deals with the basic building block of machine learning
and deep learning, the tensor.</p>
<p>Specifically, we're going to cover:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Topic</strong></th>
<th><strong>Contents</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Introduction to tensors</strong></td>
<td>Tensors are the basic building block of all of machine learning and
deep learning.</td>
</tr>
<tr class="even">
<td><strong>Creating tensors</strong></td>
<td>Tensors can represent almost any kind of data (images, words, tables
of numbers).</td>
</tr>
<tr class="odd">
<td><strong>Getting information from tensors</strong></td>
<td>If you can put information into a tensor, you'll want to get it out
too.</td>
</tr>
<tr class="even">
<td><strong>Manipulating tensors</strong></td>
<td>Machine learning algorithms (like neural networks) involve
manipulating tensors in many different ways such as adding, multiplying,
combining.</td>
</tr>
<tr class="odd">
<td><strong>Dealing with tensor shapes</strong></td>
<td>One of the most common issues in machine learning is dealing with
shape mismatches (trying to mixed wrong shaped tensors with other
tensors).</td>
</tr>
<tr class="even">
<td><strong>Indexing on tensors</strong></td>
<td>If you've indexed on a Python list or NumPy array, it's very similar
with tensors, except they can have far more dimensions.</td>
</tr>
<tr class="odd">
<td><strong>Mixing PyTorch tensors and NumPy</strong></td>
<td>PyTorch plays with tensors (<a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/tensors.html"><code>torch.Tensor</code></a>),
NumPy likes arrays (<a
target="_blank" rel="noopener" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html"><code>np.ndarray</code></a>)
sometimes you'll want to mix and match these.</td>
</tr>
<tr class="even">
<td><strong>Reproducibility</strong></td>
<td>Machine learning is very experimental and since it uses a lot of
<em>randomness</em> to work, sometimes you'll want that
<em>randomness</em> to not be so random.</td>
</tr>
<tr class="odd">
<td><strong>Running tensors on GPU</strong></td>
<td>GPUs (Graphics Processing Units) make your code faster, PyTorch
makes it easy to run your code on GPUs.</td>
</tr>
</tbody>
</table>
<h2 id="where-can-can-you-get-help">Where can can you get help?</h2>
<p>All of the materials for this course <a
target="_blank" rel="noopener" href="https://github.com/mrdbourke/pytorch-deep-learning">live on
GitHub</a>.</p>
<p>And if you run into trouble, you can ask a question on the <a
target="_blank" rel="noopener" href="https://github.com/mrdbourke/pytorch-deep-learning/discussions">Discussions
page</a> there too.</p>
<p>There's also the <a target="_blank" rel="noopener" href="https://discuss.pytorch.org/">PyTorch
developer forums</a>, a very helpful place for all things PyTorch.</p>
<h2 id="importing-pytorch">Importing PyTorch</h2>
<blockquote>
<p><strong>Note:</strong> Before running any of the code in this
notebook, you should have gone through the <a
target="_blank" rel="noopener" href="https://pytorch.org/get-started/locally/">PyTorch setup
steps</a>.</p>
<p>However, <strong>if you're running on Google Colab</strong>,
everything should work (Google Colab comes with PyTorch and other
libraries installed).</p>
</blockquote>
<p>Let's start by importing PyTorch and checking the version we're
using.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.__version__</span><br></pre></td></tr></table></figure>
<pre><code>&#39;1.10.0+cu111&#39;</code></pre>
<p>Wonderful, it looks like we've got PyTorch 1.10.0 (as of Decemeber
2021). This means if you're going through these materials, you'll see
most compatability with PyTorch 1.10.0, however if your version number
is far higher than that, you might notice some inconsistencies.</p>
<p>And if you do have any issues, please post on the GitHub Discussions
page.</p>
<h2 id="introduction-to-tensors">Introduction to tensors</h2>
<p>Now we've got PyTorch imported, it's time to learn about tensors.</p>
<p>Tensors are the fundamental building block of machine learning.</p>
<p>Their job is to represent data in a numerical way.</p>
<p>For example, you could represent an image as a tensor with shape
<code>[3, 224, 224]</code> which would mean
<code>[colour_channels, height, width]</code>, as in the image has
<code>3</code> colour channels (red, green, blue), a height of
<code>224</code> pixels and a width of <code>224</code> pixels.</p>
<figure>
<img
src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/00-tensor-shape-example-of-image.png"
alt="example of going from an input image to a tensor representation of the image, image gets broken down into 3 colour channels as well as numbers to represent the height and width" />
<figcaption aria-hidden="true">example of going from an input image to a
tensor representation of the image, image gets broken down into 3 colour
channels as well as numbers to represent the height and
width</figcaption>
</figure>
<p>In tensor-speak (the language used to describe tensors), the tensor
would have three dimensions, one for <code>colour_channels</code>,
<code>height</code> and <code>width</code>.</p>
<p>But we're getting ahead of ourselves.</p>
<p>Let's learn more about tensors by coding them.</p>
<h3 id="creating-tensors">Creating tensors</h3>
<p>PyTorch loves tensors. So much so there's a whole documentation page
dedicated to the <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.tensor.html#torch.tensor"><code>torch.Tensor</code></a>
class.</p>
<p>Your first piece of homework is to <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.tensor.html#torch.tensor">read
through the documentation on <code>torch.Tensor</code></a> for
10-minutes. But you can get to that later.</p>
<p>Let's code.</p>
<p>The first thing we're going to create is a
<strong>scalar</strong>.</p>
<p>A scalar is a single number and in tensor-speak it's a zero dimension
tensor.</p>
<blockquote>
<p><strong>Note:</strong> That's a trend for this course. We'll focus on
writing specific code. But often I'll set exercises which involve
reading and getting familiar with the PyTorch documentaiton. Because
after all, once you're finished this course, you'll no doubt want to
learn more. And the documentaiton is somewhere you'll be finding
yourself quite often.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scalar</span></span><br><span class="line">scalar = torch.tensor(<span class="number">7</span>)</span><br><span class="line">scalar</span><br></pre></td></tr></table></figure>
<pre><code>tensor(7)</code></pre>
<p>See how the above printed out <code>tensor(7)</code>?</p>
<p>That means although <code>scalar</code> is a single number, it's of
type <code>torch.Tensor</code>.</p>
<p>We can check the dimensions of a tensor using the <code>ndim</code>
attribute.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalar.ndim</span><br></pre></td></tr></table></figure>
<pre><code>0</code></pre>
<p>What if we wanted to retrieve the number from the tensor?</p>
<p>As in, turn it from <code>torch.Tensor</code> to a Python
integer?</p>
<p>To do we can use the <code>item()</code> method.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the Python number within a tensor (only works with one-element tensors)</span></span><br><span class="line">scalar.item()</span><br></pre></td></tr></table></figure>
<pre><code>7</code></pre>
<p>Okay, now let's see a <strong>vector</strong>.</p>
<p>A vector is a single dimension tensor but can contain many
numbers.</p>
<p>As in, you could have a vector <code>[3, 2]</code> to describe
<code>[bedrooms, bathrooms]</code> in your house. Or you could have
<code>[3, 2, 2]</code> to describe
<code>[bedrooms, bathrooms, car_parks]</code> in your house.</p>
<p>The important trend here is that a vector is flexible in what it can
represent (the same with tensors).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Vector</span></span><br><span class="line">vector = torch.tensor([<span class="number">7</span>, <span class="number">7</span>])</span><br><span class="line">vector</span><br></pre></td></tr></table></figure>
<pre><code>tensor([7, 7])</code></pre>
<p>Wonderful, <code>vector</code> now contains two 7's, my favourite
number.</p>
<p>How many dimensions do you think it'll have?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check the number of dimensions of vector</span></span><br><span class="line">vector.ndim</span><br></pre></td></tr></table></figure>
<pre><code>1</code></pre>
<p>Hmm, that's strange, <code>vector</code> contains two numbers but
only has a single dimension.</p>
<p>I'll let you in on a trick.</p>
<p>You can tell the number of dimensions a tensor in PyTorch has by the
number of square brackets on the outside (<code>[</code>) and you only
need to count one side.</p>
<p>How many square brackets does <code>vector</code> have?</p>
<p>Another important concept for tensors is their <code>shape</code>
attribute. The shape tells you how the elements inside them are
arranged.</p>
<p>Let's check out the shape of <code>vector</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check shape of vector</span></span><br><span class="line">vector.shape</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([2])</code></pre>
<p>The above returns <code>torch.Size([2])</code> which means our vector
has a shape of <code>[2]</code>. This is because of the two elements we
placed inside the square brackets (<code>[7, 7]</code>).</p>
<p>Let's now see a <strong>matrix</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Matrix</span></span><br><span class="line">MATRIX = torch.tensor([[<span class="number">7</span>, <span class="number">8</span>], </span><br><span class="line">                       [<span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">MATRIX</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 7,  8],
        [ 9, 10]])</code></pre>
<p>Wow! More numbers! Matrices are as flexible as vectors, except
they've got an extra dimension.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check number of dimensions</span></span><br><span class="line">MATRIX.ndim</span><br></pre></td></tr></table></figure>
<pre><code>2</code></pre>
<p><code>MATRIX</code> has two dimensions (did you count the number of
square brakcets on the outside of one side?).</p>
<p>What <code>shape</code> do you think it will have?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATRIX.shape</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([2, 2])</code></pre>
<p>We get the output <code>torch.Size([2, 2])</code> because
<code>MATRIX</code> is two elements deep and two elements wide.</p>
<p>How about we create a <strong>tensor</strong>?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tensor</span></span><br><span class="line">TENSOR = torch.tensor([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                        [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>],</span><br><span class="line">                        [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]]])</span><br><span class="line">TENSOR</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[1, 2, 3],
         [3, 6, 9],
         [2, 4, 5]]])</code></pre>
<p>Woah! What a nice looking tensor.</p>
<p>I want to stress that tensors can represent almost anything.</p>
<p>The one we just created could be the sales numbers for a steak and
almond butter store (two of my favourite foods).</p>
<figure>
<img
src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/00_simple_tensor.png"
alt="a simple tensor in google sheets showing day of week, steak sales and almond butter sales" />
<figcaption aria-hidden="true">a simple tensor in google sheets showing
day of week, steak sales and almond butter sales</figcaption>
</figure>
<p>How many dimensions do you think it has? (hint: use the square
bracket counting trick)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check number of dimensions for TENSOR</span></span><br><span class="line">TENSOR.ndim</span><br></pre></td></tr></table></figure>
<pre><code>3</code></pre>
<p>And what about its shape?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check shape of TENSOR</span></span><br><span class="line">TENSOR.shape</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([1, 3, 3])</code></pre>
<p>Alright, it outputs <code>torch.Size([1, 3, 3])</code>.</p>
<p>The dimensions go outer to inner.</p>
<p>That means there's 1 dimension of 3 by 3.</p>
<figure>
<img
src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/00-pytorch-different-tensor-dimensions.png"
alt="example of different tensor dimensions" />
<figcaption aria-hidden="true">example of different tensor
dimensions</figcaption>
</figure>
<blockquote>
<p><strong>Note:</strong> You might've noticed me using lowercase
letters for <code>scalar</code> and <code>vector</code> and uppercase
letters for <code>MATRIX</code> and <code>TENSOR</code>. This was on
purpose. In practice, you'll often see scalars and vectors denoted as
lowercase letters such as <code>y</code> or <code>a</code>. And matrices
and tensors denoted as uppercase letters such as <code>X</code> or
<code>W</code>.</p>
<p>You also might notice the names martrix and tensor used
interchangably. This is common. Since in PyTorch you're often dealing
with <code>torch.Tensor</code>'s (hence the tensor name), however, the
shape and dimensions of what's inside will dictate what it actually
is.</p>
</blockquote>
<p>Let's summarise.</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>What is it?</th>
<th>Number of dimensions</th>
<th>Lower or upper (usually/example)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>scalar</strong></td>
<td>a single number</td>
<td>0</td>
<td>Lower (<code>a</code>)</td>
</tr>
<tr class="even">
<td><strong>vector</strong></td>
<td>a number with direction (e.g. wind speed with direction) but can
also have many other numbers</td>
<td>1</td>
<td>Lower (<code>y</code>)</td>
</tr>
<tr class="odd">
<td><strong>matrix</strong></td>
<td>a 2-dimensional array of numbers</td>
<td>2</td>
<td>Upper (<code>Q</code>)</td>
</tr>
<tr class="even">
<td><strong>tensor</strong></td>
<td>an n-dimensional array of numbers</td>
<td>can be any number, a 0-dimension tensor is a scalar, a 1-dimension
tensor is a vector</td>
<td>Upper (<code>X</code>)</td>
</tr>
</tbody>
</table>
<figure>
<img
src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/00-scalar-vector-matrix-tensor.png"
alt="scalar vector matrix tensor and what they look like" />
<figcaption aria-hidden="true">scalar vector matrix tensor and what they
look like</figcaption>
</figure>
<h3 id="random-tensors">Random tensors</h3>
<p>We've established tensors represent some form of data.</p>
<p>And machine learning models such as neural networks manipulate and
seek patterns within tensors.</p>
<p>But when building machine learning models with PyTorch, it's rare
you'll create tenors by hand (like what we've being doing).</p>
<p>Instead, a machine learning model often starts out with large random
tensors of numbers and adjusts these random numbers as it works through
data to better represent it.</p>
<p>In essence:</p>
<p><code>Start with random numbers -&gt; look at data -&gt; update random numbers -&gt; look at data -&gt; update random numbers...</code></p>
<p>As a data scientist, you can define how the machine learning model
starts (initialization), looks at data (representation) and updates
(optimization) its random numbers.</p>
<p>We'll get hands on with these steps later on.</p>
<p>For now, let's see how to create a tensor of random numbers.</p>
<p>We can do so using <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.rand.html"><code>torch.rand()</code></a>
and passing in the <code>size</code> parameter.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a random tensor of size (3, 4)</span></span><br><span class="line">random_tensor = torch.rand(size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">random_tensor, random_tensor.dtype</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[0.4090, 0.2527, 0.8699, 0.2002],
         [0.8421, 0.1428, 0.1431, 0.0111],
         [0.2281, 0.0345, 0.6734, 0.3866]]), torch.float32)</code></pre>
<p>The flexibility of <code>torch.rand()</code> is that we can adjust
the <code>size</code> to be whatever we want.</p>
<p>For example, say you wanted a random tensor in the common image shape
of <code>[224, 224, 3]</code>
(<code>[height, width, color_channels</code>]).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a random tensor of size (224, 224, 3)</span></span><br><span class="line">random_image_size_tensor = torch.rand(size=(<span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>))</span><br><span class="line">random_image_size_tensor.shape, random_image_size_tensor.ndim</span><br></pre></td></tr></table></figure>
<pre><code>(torch.Size([224, 224, 3]), 3)</code></pre>
<h3 id="zeros-and-ones">Zeros and ones</h3>
<p>Sometimes you'll just want to fill tensors with zeros or ones.</p>
<p>This happens a lot with masking (like masking some of the values in
one tensor with zeros to let a model know not to learn them).</p>
<p>Let's create a tensor full of zeros with <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.zeros.html"><code>torch.zeros()</code></a></p>
<p>Again, the <code>size</code> parameter comes into play.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor of all zeros</span></span><br><span class="line">zeros = torch.zeros(size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">zeros, zeros.dtype</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]), torch.float32)</code></pre>
<p>We can do the same to create a tensor of all ones except using <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.ones.html"><code>torch.ones()</code></a>
instead.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor of all ones</span></span><br><span class="line">ones = torch.ones(size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">ones, ones.dtype</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]]), torch.float32)</code></pre>
<h3 id="creating-a-range-and-tensors-like">Creating a range and tensors
like</h3>
<p>Sometimes you might want a range of numbers, such as 1 to 10 or 0 to
100.</p>
<p>You can use <code>torch.arange(start, end, step)</code> to do so.</p>
<p>Where: * <code>start</code> = start of range (e.g. 0) *
<code>end</code> = end of range (e.g. 10) * <code>step</code> = how many
steps in between each value (e.g. 1)</p>
<blockquote>
<p><strong>Note:</strong> In Python, you can use <code>range()</code> to
create a range. However in PyTorch, <code>torch.range()</code> is
deprecated and may show an error in the future.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use torch.arange(), torch.range() is deprecated </span></span><br><span class="line">zero_to_ten_deprecated = torch.<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) <span class="comment"># Note: this may return an error in the future</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a range of values 0 to 10</span></span><br><span class="line">zero_to_ten = torch.arange(start=<span class="number">0</span>, end=<span class="number">10</span>, step=<span class="number">1</span>)</span><br><span class="line">zero_to_ten</span><br></pre></td></tr></table></figure>
<pre><code>/usr/local/lib/python3.7/dist-packages/ipykernel_launcher.py:2: UserWarning: torch.range is deprecated and will be removed in a future release because its behavior is inconsistent with Python&#39;s range builtin. Instead, use torch.arange, which produces values in [start, end).






tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre>
<p>Sometimes you might want one tensor of a certain type with the same
shape as another tensor.</p>
<p>For example, a tensor of all zeros with the same shape as a previous
tensor.</p>
<p>To do so you can use <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.zeros_like.html"><code>torch.zeros_like(input)</code></a>
or <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/1.9.1/generated/torch.ones_like.html"><code>torch.ones_like(input)</code></a>
which return a tensor filled with zeros or ones in the same shape as the
<code>input</code> respectively.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Can also create a tensor of zeros similar to another tensor</span></span><br><span class="line">ten_zeros = torch.zeros_like(<span class="built_in">input</span>=zero_to_ten) <span class="comment"># will have same shape</span></span><br><span class="line">ten_zeros</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code></pre>
<h3 id="tensor-datatypes">Tensor datatypes</h3>
<p>There are many different <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/tensors.html#data-types">tensor
datatypes available in PyTorch</a>.</p>
<p>Some are specific for CPU and some are better for GPU.</p>
<p>Getting to know which is which can take some time.</p>
<p>Generally if you see <code>torch.cuda</code> anywhere, the tensor is
being used for GPU (since Nvidia GPUs use a computing toolkit called
CUDA).</p>
<p>The most common type (and generally the default) is
<code>torch.float32</code> or <code>torch.float</code>.</p>
<p>This is referred to as "32-bit floating point".</p>
<p>But there's also 16-bit floating point (<code>torch.float16</code> or
<code>torch.half</code>) and 64-bit floating point
(<code>torch.float64</code> or <code>torch.double</code>).</p>
<p>And to confuse things even more there's also 8-bit, 16-bit, 32-bit
and 64-bit integers.</p>
<p>Plus more!</p>
<blockquote>
<p><strong>Note:</strong> An integer is a flat round number like
<code>7</code> whereas a float has a decimal <code>7.0</code>.</p>
</blockquote>
<p>The reason for all of these is to do with <strong>precision in
computing</strong>.</p>
<p>Precision is the amount of detail used to describe a number.</p>
<p>The higher the precision value (8, 16, 32), the more detail and hence
data used to express a number.</p>
<p>This matters in deep learning and numerical computing because you're
making so many operations, the more detail you have to calculate on, the
more compute you have to use.</p>
<p>So lower precision datatypes are generally faster to compute on but
sacrifice some performance on evaluation metrics like accuracy (faster
to compute but less accurate).</p>
<blockquote>
<p><strong>Resources:</strong> * See the <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/tensors.html#data-types">PyTorch
documentation for a list of all available tensor datatypes</a>. * Read
the <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Precision_(computer_science)">Wikipedia
page for an overview of what precision in computing</a> is.</p>
</blockquote>
<p>Let's see how to create some tensors with specific datatypes. We can
do so using the <code>dtype</code> parameter.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default datatype for tensors is float32</span></span><br><span class="line">float_32_tensor = torch.tensor([<span class="number">3.0</span>, <span class="number">6.0</span>, <span class="number">9.0</span>],</span><br><span class="line">                               dtype=<span class="literal">None</span>, <span class="comment"># defaults to None, which is torch.float32 or whatever datatype is passed</span></span><br><span class="line">                               device=<span class="literal">None</span>, <span class="comment"># defaults to None, which uses the default tensor type</span></span><br><span class="line">                               requires_grad=<span class="literal">False</span>) <span class="comment"># if True, operations perfromed on the tensor are recorded </span></span><br><span class="line"></span><br><span class="line">float_32_tensor.shape, float_32_tensor.dtype, float_32_tensor.device</span><br></pre></td></tr></table></figure>
<pre><code>(torch.Size([3]), torch.float32, device(type=&#39;cpu&#39;))</code></pre>
<p>Aside from shape issues (tensor shapes don't match up), two of the
other most common issues you'll come across in PyTorch are datatype and
device issues.</p>
<p>For example, one of tensors is <code>torch.float32</code> and the
other is <code>torch.float16</code> (PyTorch often likes tensors to be
the same format).</p>
<p>Or one of your tensors is on the CPU and the other is on the GPU
(PyTorch likes calculations between tensors to be on the same
device).</p>
<p>We'll see more of this device talk later on.</p>
<p>For now let's create a tensor with
<code>dtype=torch.float16</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float_16_tensor = torch.tensor([<span class="number">3.0</span>, <span class="number">6.0</span>, <span class="number">9.0</span>],</span><br><span class="line">                               dtype=torch.float16) <span class="comment"># torch.half would also work</span></span><br><span class="line"></span><br><span class="line">float_16_tensor.dtype</span><br></pre></td></tr></table></figure>
<pre><code>torch.float16</code></pre>
<h2 id="getting-information-from-tensors">Getting information from
tensors</h2>
<p>Once you've created tensors (or someone else or a PyTorch module has
created them for you), you might want to get some information from
them.</p>
<p>We've seen these before but three of the most common attributes
you'll want to find out about tensors are: * <code>shape</code> - what
shape is the tensor? (some operations require specific shape rules) *
<code>dtype</code> - what datatype are the elements within the tensor
stored in? * <code>device</code> - what device is the tensor stored on?
(usually GPU or CPU)</p>
<p>Let's create a random tensor and find out details about it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor</span></span><br><span class="line">some_tensor = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find out details about it</span></span><br><span class="line"><span class="built_in">print</span>(some_tensor)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;some_tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;some_tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;some_tensor.device&#125;</span>&quot;</span>) <span class="comment"># will default to CPU</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0.7799, 0.8140, 0.0893, 0.2062],
        [0.7525, 0.3845, 0.8207, 0.4587],
        [0.9277, 0.8166, 0.9052, 0.0953]])
Shape of tensor: torch.Size([3, 4])
Datatype of tensor: torch.float32
Device tensor is stored on: cpu</code></pre>
<blockquote>
<p><strong>Note:</strong> When you run into issues in PyTorch, it's very
often one to do with one of the three attributes above. So when the
error messages show up, sing yourself a little song called "what, what,
where": * "<em>what shape are my tensors? what datatype are they and
where are they stored? what shape, what datatype, where where
where</em>"</p>
</blockquote>
<h2 id="manipulating-tensors-tensor-operations">Manipulating tensors
(tensor operations)</h2>
<p>In deep learning, data (images, text, video, audio, protein
structures, etc) gets represented as tensors.</p>
<p>A model learns by investigating those tensors and performing a series
of operations (could be 1,000,000s+) on tensors to create a
representation of the patterns in the input data.</p>
<p>These operations are often a wonderful dance between: * Addition *
Substraction * Multiplication (element-wise) * Division * Matrix
multiplication</p>
<p>And that's it. Sure there are a few more here and there but these are
the basic building blocks of neural networks.</p>
<p>Stacking these building blocks in the right way, you can create the
most sophisticated of neural networks (just like lego!).</p>
<h3 id="basic-operations">Basic operations</h3>
<p>Let's start with a few of the fundamental operations, addition
(<code>+</code>), subtraction (<code>-</code>), mutliplication
(<code>*</code>).</p>
<p>They work just as you think they would.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor of values and add a number to it</span></span><br><span class="line">tensor = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tensor + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor([11, 12, 13])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Multiply it by 10</span></span><br><span class="line">tensor * <span class="number">10</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor([10, 20, 30])</code></pre>
<p>Notice how the tensor values above didn't end up being
<code>tensor([110, 120, 130])</code>, this is because the values inside
the tensor don't change unless they're reassigned.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tensors don&#x27;t change unless reassigned</span></span><br><span class="line">tensor</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 2, 3])</code></pre>
<p>Let's subtract a number and this time we'll reassign the
<code>tensor</code> variable.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Subtract and reassign</span></span><br><span class="line">tensor = tensor - <span class="number">10</span></span><br><span class="line">tensor</span><br></pre></td></tr></table></figure>
<pre><code>tensor([-9, -8, -7])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add and reassign</span></span><br><span class="line">tensor = tensor + <span class="number">10</span></span><br><span class="line">tensor</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 2, 3])</code></pre>
<p>PyTorch also has a bunch of built-in functions like <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.mul.html#torch.mul"><code>torch.mul()</code></a>
(short for multiplcation) and <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.add.html"><code>torch.add()</code></a>
to perform basic operations.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Can also use torch functions</span></span><br><span class="line">torch.multiply(tensor, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([10, 20, 30])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Original tensor is still unchanged </span></span><br><span class="line">tensor</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 2, 3])</code></pre>
<p>However, it's more common to use the operator symbols like
<code>*</code> instead of <code>torch.mul()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Element-wise multiplication (each element multiplies its equivalent, index 0-&gt;0, 1-&gt;1, 2-&gt;2)</span></span><br><span class="line"><span class="built_in">print</span>(tensor, <span class="string">&quot;*&quot;</span>, tensor)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Equals:&quot;</span>, tensor * tensor)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 2, 3]) * tensor([1, 2, 3])
Equals: tensor([1, 4, 9])</code></pre>
<h3 id="matrix-multiplication-is-all-you-need">Matrix multiplication (is
all you need)</h3>
<p>One of the most common operations in machine learning and deep
learning algorithms (like neural networks) is <a
target="_blank" rel="noopener" href="https://www.mathsisfun.com/algebra/matrix-multiplying.html">matrix
multiplication</a>.</p>
<p>PyTorch implements matrix multiplication functionality in the <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.matmul.html"><code>torch.matmul()</code></a>
method.</p>
<p>The main two rules for matrix multiplication to remember are: 1. The
<strong>inner dimensions</strong> must match: *
<code>(3, 2) @ (3, 2)</code> won't work * <code>(2, 3) @ (3, 2)</code>
will work * <code>(3, 2) @ (2, 3)</code> will work 2. The resulting
matrix has the shape of the <strong>outer dimensions</strong>: *
<code>(2, 3) @ (3, 2)</code> -&gt; <code>(2, 2)</code> *
<code>(3, 2) @ (2, 3)</code> -&gt; <code>(3, 3)</code></p>
<blockquote>
<p><strong>Note:</strong> "<code>@</code>" in Python is the symbol for
matrix multiplication.</p>
</blockquote>
<blockquote>
<p><strong>Resource:</strong> You can see all of the rules for matrix
multiplication using <code>torch.matmul()</code> <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.matmul.html">in
the PyTorch documentation</a>.</p>
</blockquote>
<p>Let's create a tensor and perform element-wise multiplication and
matrix multiplication on it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">tensor = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tensor.shape</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([3])</code></pre>
<p>The difference between element-wise multiplication and matrix
multiplication is the addition of values.</p>
<p>For our <code>tensor</code> variable with values
<code>[1, 2, 3]</code>:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Calculation</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Element-wise multiplication</strong></td>
<td><code>[1*1, 2*2, 3*3]</code> = <code>[1, 4, 9]</code></td>
<td><code>tensor * tensor</code></td>
</tr>
<tr class="even">
<td><strong>Matrix multiplication</strong></td>
<td><code>[1*1 + 2*2 + 3*3]</code> = <code>[14]</code></td>
<td><code>tensor.matmul(tensor)</code></td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Element-wise matrix mutlication</span></span><br><span class="line">tensor * tensor</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 4, 9])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Matrix multiplication</span></span><br><span class="line">torch.matmul(tensor, tensor)</span><br></pre></td></tr></table></figure>
<pre><code>tensor(14)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Can also use the &quot;@&quot; symbol for matrix multiplication, though not recommended</span></span><br><span class="line">tensor @ tensor</span><br></pre></td></tr></table></figure>
<pre><code>tensor(14)</code></pre>
<p>You can do matrix multiplication by hand but it's not
recommended.</p>
<p>The in-built <code>torch.matmul()</code> method is faster.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="comment"># Matrix multiplication by hand </span></span><br><span class="line"><span class="comment"># (avoid doing operations with for loops at all cost, they are computationally expensive)</span></span><br><span class="line">value = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tensor)):</span><br><span class="line">  value += tensor[i] * tensor[i]</span><br><span class="line">value</span><br></pre></td></tr></table></figure>
<pre><code>CPU times: user 146 µs, sys: 38 µs, total: 184 µs
Wall time: 227 µs</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">torch.matmul(tensor, tensor)</span><br></pre></td></tr></table></figure>
<pre><code>CPU times: user 27 µs, sys: 7 µs, total: 34 µs
Wall time: 36.7 µs





tensor(14)</code></pre>
<h2 id="one-of-the-most-common-errors-in-deep-learning-shape-errors">One
of the most common errors in deep learning (shape errors)</h2>
<p>Because much of deep learning is multiplying and performing
operations on matrices and matrices have a strict rule about what shapes
and sizes can be combined, one of the most common errors you'll run into
in deep learning is shape mismatches.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Shapes need to be in the right way  </span></span><br><span class="line">tensor_A = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                         [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                         [<span class="number">5</span>, <span class="number">6</span>]], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">tensor_B = torch.tensor([[<span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line">                         [<span class="number">8</span>, <span class="number">11</span>], </span><br><span class="line">                         [<span class="number">9</span>, <span class="number">12</span>]], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">torch.matmul(tensor_A, tensor_B) <span class="comment"># (this will error)</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

&lt;ipython-input-37-aceec990e652&gt; in &lt;module&gt;()
      8                          [9, 12]], dtype=torch.float32)
      9 
---&gt; 10 torch.matmul(tensor_A, tensor_B) # (this will error)


RuntimeError: mat1 and mat2 shapes cannot be multiplied (3x2 and 3x2)</code></pre>
<p>We can make matrix multiplication work between <code>tensor_A</code>
and <code>tensor_B</code> by making their inner dimensions match.</p>
<p>One of the ways to do this is with a <strong>transpose</strong>
(switch the dimensions of a given tensor).</p>
<p>You can perform transposes in PyTorch using either: *
<code>torch.transpose(input, dim0, dim1)</code> - where
<code>input</code> is the desired tensor to transpose and
<code>dim0</code> and <code>dim1</code> are the dimensions to be
swapped. * <code>tensor.T</code> - where <code>tensor</code> is the
desired tensor to transpose.</p>
<p>Let's try the latter.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># View tensor_A and tensor_B</span></span><br><span class="line"><span class="built_in">print</span>(tensor_A)</span><br><span class="line"><span class="built_in">print</span>(tensor_B)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 2.],
        [3., 4.],
        [5., 6.]])
tensor([[ 7., 10.],
        [ 8., 11.],
        [ 9., 12.]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># View tensor_A and tensor_B.T</span></span><br><span class="line"><span class="built_in">print</span>(tensor_A)</span><br><span class="line"><span class="built_in">print</span>(tensor_B.T)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 2.],
        [3., 4.],
        [5., 6.]])
tensor([[ 7.,  8.,  9.],
        [10., 11., 12.]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The operation works when tensor_B is transposed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Original shapes: tensor_A = <span class="subst">&#123;tensor_A.shape&#125;</span>, tensor_B = <span class="subst">&#123;tensor_B.shape&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;New shapes: tensor_A = <span class="subst">&#123;tensor_A.shape&#125;</span> (same as above), tensor_B.T = <span class="subst">&#123;tensor_B.T.shape&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Multiplying: <span class="subst">&#123;tensor_A.shape&#125;</span> * <span class="subst">&#123;tensor_B.T.shape&#125;</span> &lt;- inner dimensions match\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Output:\n&quot;</span>)</span><br><span class="line">output = torch.matmul(tensor_A, tensor_B.T)</span><br><span class="line"><span class="built_in">print</span>(output) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nOutput shape: <span class="subst">&#123;output.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Original shapes: tensor_A = torch.Size([3, 2]), tensor_B = torch.Size([3, 2])

New shapes: tensor_A = torch.Size([3, 2]) (same as above), tensor_B.T = torch.Size([2, 3])

Multiplying: torch.Size([3, 2]) * torch.Size([2, 3]) &lt;- inner dimensions match

Output:

tensor([[ 27.,  30.,  33.],
        [ 61.,  68.,  75.],
        [ 95., 106., 117.]])

Output shape: torch.Size([3, 3])</code></pre>
<p>You can also use <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.mm.html"><code>torch.mm()</code></a>
which is a short for <code>torch.matmul()</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># torch.mm is a shortcut for matmul</span></span><br><span class="line">torch.mm(tensor_A, tensor_B.T)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 27.,  30.,  33.],
        [ 61.,  68.,  75.],
        [ 95., 106., 117.]])</code></pre>
<p>Without the transpose, the rules of matrix mulitplication aren't
fulfilled and we get an error like above.</p>
<p>How about a visual?</p>
<figure>
<img
src="https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/00-matrix-multiply-crop.gif"
alt="visual demo of matrix multiplication" />
<figcaption aria-hidden="true">visual demo of matrix
multiplication</figcaption>
</figure>
<p>You can create your own matrix multiplication visuals like this at
http://matrixmultiplication.xyz/.</p>
<blockquote>
<p><strong>Note:</strong> A matrix multiplication like this is also
referred to as the <a
target="_blank" rel="noopener" href="https://www.mathsisfun.com/algebra/vectors-dot-product.html"><strong>dot
product</strong></a> of two matrices.</p>
</blockquote>
<p>Neural networks are full of matrix multiplications and dot
products.</p>
<p>The <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/1.9.1/generated/torch.nn.Linear.html"><code>torch.nn.Linear()</code></a>
module (we'll see this in action later on), also known as a feed-forward
layer or fully connected layer, implements a matrix multiplication
between an input <code>x</code> and a weights matrix <code>A</code>.</p>
<p><span class="math display">\[
y = x\cdot{A^T} + b
\]</span></p>
<p>Where: * <code>x</code> is the input to the layer (deep learning is a
stack of layers like <code>torch.nn.Linear()</code> and others on top of
each other). * <code>A</code> is the weights matrix created by the
layer, this starts out as random numbers that get adjusted as a neural
network learns to better represent patterns in the data (notice the
"<code>T</code>", that's because the weights matrix gets transposed). *
<strong>Note:</strong> You might also often see <code>W</code> or
another letter like <code>X</code> used to showcase the weights matrix.
* <code>b</code> is the bias term used to slightly offset the weights
and inputs. * <code>y</code> is the output (a manipulation of the input
in the hopes to discover patterns in it).</p>
<p>This is a linear function (you may have seen something like <span
class="math inline">\(y = mx+b\)</span> in high school or elsewhere),
and can be used to draw a straight line!</p>
<p>Let's play around with a linear layer.</p>
<p>Try changing the values of <code>in_features</code> and
<code>out_features</code> below and see what happens.</p>
<p>Do you notice anything to do with the shapes?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Since the linear layer starts with a random weights matrix, let&#x27;s make it reproducible (more on this later)</span></span><br><span class="line">torch.manual_seed(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># This uses matrix mutliplcation</span></span><br><span class="line">linear = torch.nn.Linear(in_features=<span class="number">2</span>, <span class="comment"># in_features = matches inner dimension of input </span></span><br><span class="line">                         out_features=<span class="number">6</span>) <span class="comment"># out_features = describes outer value </span></span><br><span class="line">x = tensor_A</span><br><span class="line">output = linear(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Input shape: <span class="subst">&#123;x.shape&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Output:\n<span class="subst">&#123;output&#125;</span>\n\nOutput shape: <span class="subst">&#123;output.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Input shape: torch.Size([3, 2])

Output:
tensor([[2.2368, 1.2292, 0.4714, 0.3864, 0.1309, 0.9838],
        [4.4919, 2.1970, 0.4469, 0.5285, 0.3401, 2.4777],
        [6.7469, 3.1648, 0.4224, 0.6705, 0.5493, 3.9716]],
       grad_fn=&lt;AddmmBackward0&gt;)

Output shape: torch.Size([3, 6])</code></pre>
<blockquote>
<p><strong>Question:</strong> What happens if you change
<code>in_features</code> from 2 to 3 above? Does it error? How could you
change the shape of the input (<code>x</code>) to accomodate to the
error? Hint: what did we have to do to <code>tensor_B</code> above?</p>
</blockquote>
<p>If you've never done it before, matrix multiplication can be a
confusing topic at first.</p>
<p>But after you've played around with it a few times and even cracked
open a few neural networks, you'll notice it's everywhere.</p>
<p>Remember, matrix multiplication is all you need.</p>
<figure>
<img
src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/00_matrix_multiplication_is_all_you_need.jpeg"
alt="matrix multiplication is all you need" />
<figcaption aria-hidden="true">matrix multiplication is all you
need</figcaption>
</figure>
<p><em>When you start digging into neural network layers and building
your own, you'll find matrix multiplications everywhere.
<strong>Source:</strong>
https://marksaroufim.substack.com/p/working-class-deep-learner</em></p>
<h3 id="finding-the-min-max-mean-sum-etc-aggregation">Finding the min,
max, mean, sum, etc (aggregation)</h3>
<p>Now we've seen a few ways to manipulate tensors, let's run through a
few ways to aggregate them (go from more values to less values).</p>
<p>First we'll create a tensor and then find the max, min, mean and sum
of it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor</span></span><br><span class="line">x = torch.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])</code></pre>
<p>Now let's perform some aggregation.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Minimum: <span class="subst">&#123;x.<span class="built_in">min</span>()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Maximum: <span class="subst">&#123;x.<span class="built_in">max</span>()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># print(f&quot;Mean: &#123;x.mean()&#125;&quot;) # this will error</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Mean: <span class="subst">&#123;x.<span class="built_in">type</span>(torch.float32).mean()&#125;</span>&quot;</span>) <span class="comment"># won&#x27;t work without float datatype</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Sum: <span class="subst">&#123;x.<span class="built_in">sum</span>()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Minimum: 0
Maximum: 90
Mean: 45.0
Sum: 450</code></pre>
<blockquote>
<p><strong>Note:</strong> You may find some methods such as
<code>torch.mean()</code> require tensors to be in
<code>torch.float32</code> (the most common) or another specific
datatype, otherwise the operation will fail.</p>
</blockquote>
<p>You can also do the same as above with <code>torch</code>
methods.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">max</span>(x), torch.<span class="built_in">min</span>(x), torch.mean(x.<span class="built_in">type</span>(torch.float32)), torch.<span class="built_in">sum</span>(x)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor(90), tensor(0), tensor(45.), tensor(450))</code></pre>
<h3 id="positional-minmax">Positional min/max</h3>
<p>You can also find the index of a tensor where the max or minimum
occurs with <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.argmax.html"><code>torch.argmax()</code></a>
and <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.argmin.html"><code>torch.argmin()</code></a>
respectively.</p>
<p>This is helpful incase you just want the position where the highest
(or lowest) value is and not the actual value itself (we'll see this in
a later section when using the <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.nn.Softmax.html">softmax
activation function</a>).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor</span></span><br><span class="line">tensor = torch.arange(<span class="number">10</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Tensor: <span class="subst">&#123;tensor&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns index of max and min values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Index where max value occurs: <span class="subst">&#123;tensor.argmax()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Index where min value occurs: <span class="subst">&#123;tensor.argmin()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Tensor: tensor([10, 20, 30, 40, 50, 60, 70, 80, 90])
Index where max value occurs: 8
Index where min value occurs: 0</code></pre>
<h3 id="change-tensor-datatype">Change tensor datatype</h3>
<p>As mentioned, a common issue with deep learning operations is having
your tensors in different datatypes.</p>
<p>If one tensor is in <code>torch.float64</code> and another is in
<code>torch.float32</code>, you might run into some errors.</p>
<p>But there's a fix.</p>
<p>You can change the datatypes of tensors using <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.Tensor.type.html"><code>torch.Tensor.type(dtype=None)</code></a>
where the <code>dtype</code> parameter is the datatype you'd like to
use.</p>
<p>First we'll create a tensor and check it's datatype (the default is
<code>torch.float32</code>).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor and check its datatype</span></span><br><span class="line">tensor = torch.arange(<span class="number">10.</span>, <span class="number">100.</span>, <span class="number">10.</span>)</span><br><span class="line">tensor.dtype</span><br></pre></td></tr></table></figure>
<pre><code>torch.float32</code></pre>
<p>Now we'll create another tensor the same as before but change its
datatype to <code>torch.float16</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a float16 tensor</span></span><br><span class="line">tensor_float16 = tensor.<span class="built_in">type</span>(torch.float16)</span><br><span class="line">tensor_float16</span><br></pre></td></tr></table></figure>
<pre><code>tensor([10., 20., 30., 40., 50., 60., 70., 80., 90.], dtype=torch.float16)</code></pre>
<p>And we can do something similar to make a <code>torch.int8</code>
tensor.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a int8 tensor</span></span><br><span class="line">tensor_int8 = tensor.<span class="built_in">type</span>(torch.int8)</span><br><span class="line">tensor_int8</span><br></pre></td></tr></table></figure>
<pre><code>tensor([10, 20, 30, 40, 50, 60, 70, 80, 90], dtype=torch.int8)</code></pre>
<blockquote>
<p><strong>Note:</strong> Different datatypes can be confusing to begin
with. But think of it like this, the lower the number (e.g. 32, 16, 8),
the less precise a computer stores the value. And with a lower amount of
storage, this generally results in faster computation and a smaller
overall model. Mobile-based neural networks often operate with 8-bit
integers, smaller and faster to run but less accurate than their float32
counterparts. For more on this, I'd read up about <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Precision_(computer_science)">precision
in computing</a>.</p>
</blockquote>
<blockquote>
<p><strong>Exercise:</strong> So far we've covered a fair few tensor
methods but there's a bunch more in the <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/tensors.html"><code>torch.Tensor</code>
documentation</a>, I'd recommend spending 10-minutes scrolling through
and looking into any that catch your eye. Click on them and then write
them out in code yourself to see what happens.</p>
</blockquote>
<h3 id="reshaping-stacking-squeezing-and-unsqueezing">Reshaping,
stacking, squeezing and unsqueezing</h3>
<p>Often times you'll want to reshape or change the dimensions of your
tensors without actually changing the values inside them.</p>
<p>To do so, some popular methods are:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>One-line description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.reshape.html#torch.reshape"><code>torch.reshape(input, shape)</code></a></td>
<td>Reshapes <code>input</code> to <code>shape</code> (if compatible),
can also use <code>torch.Tensor.reshape()</code>.</td>
</tr>
<tr class="even">
<td><a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.Tensor.view.html"><code>torch.Tensor.view(shape)</code></a></td>
<td>Returns a view of the original tensor in a different
<code>shape</code> but shares the same data as the original tensor.</td>
</tr>
<tr class="odd">
<td><a
target="_blank" rel="noopener" href="https://pytorch.org/docs/1.9.1/generated/torch.stack.html"><code>torch.stack(tensors, dim=0)</code></a></td>
<td>Concatenates a sequence of <code>tensors</code> along a new
dimension (<code>dim</code>), all <code>tensors</code> must be same
size.</td>
</tr>
<tr class="even">
<td><a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.squeeze.html"><code>torch.squeeze(input)</code></a></td>
<td>Squeezes <code>input</code> to remove all the dimenions with value
<code>1</code>.</td>
</tr>
<tr class="odd">
<td><a
target="_blank" rel="noopener" href="https://pytorch.org/docs/1.9.1/generated/torch.unsqueeze.html"><code>torch.unsqueeze(input, dim)</code></a></td>
<td>Returns <code>input</code> with a dimension value of <code>1</code>
added at <code>dim</code>.</td>
</tr>
<tr class="even">
<td><a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.permute.html"><code>torch.permute(input, dims)</code></a></td>
<td>Returns a <em>view</em> of the original <code>input</code> with its
dimensions permuted (rearranged) to <code>dims</code>.</td>
</tr>
</tbody>
</table>
<p>Why do any of these?</p>
<p>Because deep learning models (neural networks) are all about
manipulating tensors in some way. And because of the rules of matrix
multiplication, if you've got shape mismatches, you'll run into errors.
These methods help you make the right elements of your tensors are
mixing with the right elements of other tensors.</p>
<p>Let's try them out.</p>
<p>First, we'll create a tensor.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.arange(<span class="number">1.</span>, <span class="number">8.</span>)</span><br><span class="line">x, x.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([1., 2., 3., 4., 5., 6., 7.]), torch.Size([7]))</code></pre>
<p>Now let's add an extra dimension with
<code>torch.reshape()</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add an extra dimension</span></span><br><span class="line">x_reshaped = x.reshape(<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">x_reshaped, x_reshaped.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[1., 2., 3., 4., 5., 6., 7.]]), torch.Size([1, 7]))</code></pre>
<p>We can also change the view with <code>torch.view()</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Change view (keeps same data as original but changes view)</span></span><br><span class="line"><span class="comment"># See more: https://stackoverflow.com/a/54507446/7900723</span></span><br><span class="line">z = x.view(<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">z, z.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[1., 2., 3., 4., 5., 6., 7.]]), torch.Size([1, 7]))</code></pre>
<p>Remember though, changing the view of a tensor with
<code>torch.view()</code> really only creates a new view of the
<em>same</em> tensor.</p>
<p>So changing the view changes the original tensor too.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Changing z changes x</span></span><br><span class="line">z[:, <span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">z, x</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[5., 2., 3., 4., 5., 6., 7.]]), tensor([5., 2., 3., 4., 5., 6., 7.]))</code></pre>
<p>If we wanted to stack our new tensor on top of itself five times, we
could do so with <code>torch.stack()</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stack tensors on top of each other</span></span><br><span class="line">x_stacked = torch.stack([x, x, x, x], dim=<span class="number">0</span>) <span class="comment"># try changing dim to dim=1 and see what happens</span></span><br><span class="line">x_stacked</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[5., 2., 3., 4., 5., 6., 7.],
        [5., 2., 3., 4., 5., 6., 7.],
        [5., 2., 3., 4., 5., 6., 7.],
        [5., 2., 3., 4., 5., 6., 7.]])</code></pre>
<p>How about removing all single dimensions from a tensor?</p>
<p>To do so you can use <code>torch.squeeze()</code> (I remember this as
<em>squeezing</em> the tensor to only have dimensions over 1).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Previous tensor: <span class="subst">&#123;x_reshaped&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Previous shape: <span class="subst">&#123;x_reshaped.shape&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove extra dimension from x_reshaped</span></span><br><span class="line">x_squeezed = x_reshaped.squeeze()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nNew tensor: <span class="subst">&#123;x_squeezed&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;New shape: <span class="subst">&#123;x_squeezed.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Previous tensor: tensor([[5., 2., 3., 4., 5., 6., 7.]])
Previous shape: torch.Size([1, 7])

New tensor: tensor([5., 2., 3., 4., 5., 6., 7.])
New shape: torch.Size([7])</code></pre>
<p>And to do the reverse of <code>torch.squeeze()</code> you can use
<code>torch.unsqueeze()</code> to add a dimension value of 1 at a
specific index.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Previous tensor: <span class="subst">&#123;x_squeezed&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Previous shape: <span class="subst">&#123;x_squeezed.shape&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add an extra dimension with unsqueeze</span></span><br><span class="line">x_unsqueezed = x_squeezed.unsqueeze(dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nNew tensor: <span class="subst">&#123;x_unsqueezed&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;New shape: <span class="subst">&#123;x_unsqueezed.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Previous tensor: tensor([5., 2., 3., 4., 5., 6., 7.])
Previous shape: torch.Size([7])

New tensor: tensor([[5., 2., 3., 4., 5., 6., 7.]])
New shape: torch.Size([1, 7])</code></pre>
<p>You can also rearrange the order of axes values with
<code>torch.permute(input, dims)</code>, where the <code>input</code>
gets turned into a <em>view</em> with new <code>dims</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create tensor with specific shape</span></span><br><span class="line">x_original = torch.rand(size=(<span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Permute the original tensor to rearrange the axis order</span></span><br><span class="line">x_permuted = x_original.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment"># shifts axis 0-&gt;1, 1-&gt;2, 2-&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Previous shape: <span class="subst">&#123;x_original.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;New shape: <span class="subst">&#123;x_permuted.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Previous shape: torch.Size([224, 224, 3])
New shape: torch.Size([3, 224, 224])</code></pre>
<blockquote>
<p><strong>Note</strong>: Because permuting returns a <em>view</em>
(shares the same data as the original), the values in the permuted
tensor will be the same as the original tensor and if you change the
values in the view, it will change the values of the original.</p>
</blockquote>
<h2 id="indexing-selecting-data-from-tensors">Indexing (selecting data
from tensors)</h2>
<p>Sometimes you'll want to select specific data from tensors (for
example, only the first column or second row).</p>
<p>To do so, you can use indexing.</p>
<p>If you've ever done indexing on Python lists or NumPy arrays,
indexing in PyTorch with tensors is very similar.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a tensor </span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.arange(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">x, x.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]]]), torch.Size([1, 3, 3]))</code></pre>
<p>Indexing values goes outer dimension -&gt; inner dimension (check out
the square brackets).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let&#x27;s index bracket by bracket</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First square bracket:\n<span class="subst">&#123;x[<span class="number">0</span>]&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Second square bracket: <span class="subst">&#123;x[<span class="number">0</span>][<span class="number">0</span>]&#125;</span>&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Third square bracket: <span class="subst">&#123;x[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>First square bracket:
tensor([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
Second square bracket: tensor([1, 2, 3])
Third square bracket: 1</code></pre>
<p>You can also use <code>:</code> to specify "all values in this
dimension" and then use a comma (<code>,</code>) to add another
dimension.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get all values of 0th dimension and the 0 index of 1st dimension</span></span><br><span class="line">x[:, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1, 2, 3]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get all values of 0th &amp; 1st dimensions but only index 1 of 2nd dimension</span></span><br><span class="line">x[:, :, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[2, 5, 8]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get all values of the 0 dimension but only the 1 index value of the 1st and 2nd dimension</span></span><br><span class="line">x[:, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>tensor([5])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get index 0 of 0th and 1st dimension and all values of 2nd dimension </span></span><br><span class="line">x[<span class="number">0</span>, <span class="number">0</span>, :] <span class="comment"># same as x[0][0]</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 2, 3])</code></pre>
<p>Indexing can be quite confusing to begin with, especially with larger
tensors (I still have to try indexing multiple times to get it right).
But with a bit of practice and following the data explorer's motto
(<strong><em>visualize, visualize, visualize</em></strong>), you'll
start to get the hang of it.</p>
<h2 id="pytorch-tensors-numpy">PyTorch tensors &amp; NumPy</h2>
<p>Since NumPy is a popular Python numerical computing library, PyTorch
has functionality to interact with it nicely.</p>
<p>The two main methods you'll want to use for NumPy to PyTorch (and
back again) are: * <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.from_numpy.html"><code>torch.from_numpy(ndarray)</code></a>
- NumPy array -&gt; PyTorch tensor. * <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.Tensor.numpy.html"><code>torch.Tensor.numpy()</code></a>
- PyTorch tensor -&gt; NumPy array.</p>
<p>Let's try them out.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy array to tensor</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.arange(<span class="number">1.0</span>, <span class="number">8.0</span>)</span><br><span class="line">tensor = torch.from_numpy(array)</span><br><span class="line">array, tensor</span><br></pre></td></tr></table></figure>
<pre><code>(array([1., 2., 3., 4., 5., 6., 7.]),
 tensor([1., 2., 3., 4., 5., 6., 7.], dtype=torch.float64))</code></pre>
<blockquote>
<p><strong>Note:</strong> By default, NumPy arrays are created with the
datatype <code>float64</code> and if you convert it to a PyTorch tensor,
it'll keep the same datatype (as above).</p>
<p>However, many PyTorch calculations default to using
<code>float32</code>.</p>
<p>So if you want to convert your NumPy array (float64) -&gt; PyTorch
tensor (float64) -&gt; PyTorch tensor (float32), you can use
<code>tensor = torch.from_numpy(array).type(torch.float32)</code>.</p>
</blockquote>
<p>Because we reassigned <code>tensor</code> above, if you change the
tensor, the array stays the same.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Change the array, keep the tensor</span></span><br><span class="line">array = array + <span class="number">1</span></span><br><span class="line">array, tensor</span><br></pre></td></tr></table></figure>
<pre><code>(array([2., 3., 4., 5., 6., 7., 8.]),
 tensor([1., 2., 3., 4., 5., 6., 7.], dtype=torch.float64))</code></pre>
<p>And if you want to go from PyTorch tensor to NumPy array, you can
call <code>tensor.numpy()</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tensor to NumPy array</span></span><br><span class="line">tensor = torch.ones(<span class="number">7</span>) <span class="comment"># create a tensor of ones with dtype=float32</span></span><br><span class="line">numpy_tensor = tensor.numpy() <span class="comment"># will be dtype=float32 unless changed</span></span><br><span class="line">tensor, numpy_tensor</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([1., 1., 1., 1., 1., 1., 1.]),
 array([1., 1., 1., 1., 1., 1., 1.], dtype=float32))</code></pre>
<p>And the same rule applies as above, if you change the original
<code>tensor</code>, the new <code>numpy_tensor</code> stays the
same.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Change the tensor, keep the array the same</span></span><br><span class="line">tensor = tensor + <span class="number">1</span></span><br><span class="line">tensor, numpy_tensor</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([2., 2., 2., 2., 2., 2., 2.]),
 array([1., 1., 1., 1., 1., 1., 1.], dtype=float32))</code></pre>
<h2
id="reproducibility-trying-to-take-the-random-out-of-random">Reproducibility
(trying to take the random out of random)</h2>
<p>As you learn more about neural networks and machine learning, you'll
start to discover how much randomness plays a part.</p>
<p>Well, pseudorandomness that is. Because after all, as they're
designed, a computer is fundamentally deterministic (each step is
predictable) so the randomness they create are simulated randomness
(though there is debate on this too, but since I'm not a computer
scientist, I'll let you find out more yourself).</p>
<p>How does this relate to neural networks and deep learning then?</p>
<p>We've discussed neural networks start with random numbers to describe
patterns in data (these numbers are poor descriptions) and try to
improve those random numbers using tensor operations (and a few other
things we haven't discussed yet) to better describe patterns in
data.</p>
<p>In short:</p>
<p><code>start with random numbers -&gt; tensor operations -&gt; try to make better (again and again and again)</code></p>
<p>Although randomness is nice and powerful, sometimes you'd like there
to be a little less randomness.</p>
<p>Why?</p>
<p>So you can perform repeatable experiments.</p>
<p>For example, you create an algorithm capable of achieving X
performance.</p>
<p>And then your friend tries it out to verify you're not crazy.</p>
<p>How could they do such a thing?</p>
<p>That's where <strong>reproducibility</strong> comes in.</p>
<p>In other words, can you get the same (or very similar) results on
your computer running the same code as I get on mine?</p>
<p>Let's see a brief example of reproducibility in PyTorch.</p>
<p>We'll start by creating two random tensors, since they're random,
you'd expect them to be different right?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create two random tensors</span></span><br><span class="line">random_tensor_A = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">random_tensor_B = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Tensor A:\n<span class="subst">&#123;random_tensor_A&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Tensor B:\n<span class="subst">&#123;random_tensor_B&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does Tensor A equal Tensor B? (anywhere)&quot;</span>)</span><br><span class="line">random_tensor_A == random_tensor_B</span><br></pre></td></tr></table></figure>
<pre><code>Tensor A:
tensor([[0.8016, 0.3649, 0.6286, 0.9663],
        [0.7687, 0.4566, 0.5745, 0.9200],
        [0.3230, 0.8613, 0.0919, 0.3102]])

Tensor B:
tensor([[0.9536, 0.6002, 0.0351, 0.6826],
        [0.3743, 0.5220, 0.1336, 0.9666],
        [0.9754, 0.8474, 0.8988, 0.1105]])

Does Tensor A equal Tensor B? (anywhere)





tensor([[False, False, False, False],
        [False, False, False, False],
        [False, False, False, False]])</code></pre>
<p>Just as you might've expected, the tensors come out with different
values.</p>
<p>But what if you wanted to created two random tensors with the
<em>same</em> values.</p>
<p>As in, the tensors would still contain random values but they would
be of the same flavour.</p>
<p>That's where <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.manual_seed.html"><code>torch.manual_seed(seed)</code></a>
comes in, where <code>seed</code> is an integer (like <code>42</code>
but it could be anything) that flavours the randomness.</p>
<p>Let's try it out by creating some more <em>flavoured</em> random
tensors.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># # Set the random seed</span></span><br><span class="line">RANDOM_SEED=<span class="number">42</span> <span class="comment"># try changing this to different values and see what happens to the numbers below</span></span><br><span class="line">torch.manual_seed(seed=RANDOM_SEED) </span><br><span class="line">random_tensor_C = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Have to reset the seed every time a new rand() is called </span></span><br><span class="line"><span class="comment"># Without this, tensor_D would be different to tensor_C </span></span><br><span class="line">torch.random.manual_seed(seed=RANDOM_SEED) <span class="comment"># try commenting this line out and seeing what happens</span></span><br><span class="line">random_tensor_D = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Tensor C:\n<span class="subst">&#123;random_tensor_C&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Tensor D:\n<span class="subst">&#123;random_tensor_D&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does Tensor C equal Tensor D? (anywhere)&quot;</span>)</span><br><span class="line">random_tensor_C == random_tensor_D</span><br></pre></td></tr></table></figure>
<pre><code>Tensor C:
tensor([[0.8823, 0.9150, 0.3829, 0.9593],
        [0.3904, 0.6009, 0.2566, 0.7936],
        [0.9408, 0.1332, 0.9346, 0.5936]])

Tensor D:
tensor([[0.8823, 0.9150, 0.3829, 0.9593],
        [0.3904, 0.6009, 0.2566, 0.7936],
        [0.9408, 0.1332, 0.9346, 0.5936]])

Does Tensor C equal Tensor D? (anywhere)





tensor([[True, True, True, True],
        [True, True, True, True],
        [True, True, True, True]])</code></pre>
<p>Nice!</p>
<p>It looks like setting the seed worked.</p>
<blockquote>
<p><strong>Resource:</strong> What we've just covered only scratches the
surface of reproducibility in PyTorch. For more, on reproducbility in
general and random seeds, I'd checkout: * <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/notes/randomness.html">The PyTorch
reproducibility documentation</a> (a good exericse would be to read
through this for 10-minutes and even if you don't understand it now,
being aware of it is important). * <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Random_seed">The Wikipedia random
seed page</a> (this'll give a good overview of random seeds and
pseudorandomness in general).</p>
</blockquote>
<h2 id="running-tensors-on-gpus-and-making-faster-computations">Running
tensors on GPUs (and making faster computations)</h2>
<p>Deep learning algorithms require a lot of numerical operations.</p>
<p>And by default these operations are often done on a CPU (computer
processing unit).</p>
<p>However, there's another common piece of hardware called a GPU
(graphics processing unit), which is often much faster at performing the
specific types of operations neural networks need (matrix
multiplications) than CPUs.</p>
<p>Your computer might have one.</p>
<p>If so, you should look to use it whenever you can to train neural
networks because chances are it'll speed up the training time
dramatically.</p>
<p>There are a few ways to first get access to a GPU and secondly get
PyTorch to use the GPU.</p>
<blockquote>
<p><strong>Note:</strong> When I reference "GPU" throughout this course,
I'm referencing a <a
target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-gpus">Nvidia GPU with CUDA</a>
enabled (CUDA is a computing platform and API that helps allow GPUs be
used for general purpose computing &amp; not just graphics) unless
otherwise specified.</p>
</blockquote>
<h3 id="getting-a-gpu">1. Getting a GPU</h3>
<p>You may already know what's going on when I say GPU. But if not,
there are a few ways to get access to one.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Method</strong></th>
<th><strong>Difficulty to setup</strong></th>
<th><strong>Pros</strong></th>
<th><strong>Cons</strong></th>
<th><strong>How to setup</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Google Colab</td>
<td>Easy</td>
<td>Free to use, almost zero setup required, can share work with others
as easy as a link</td>
<td>Doesn't save your data outputs, limited compute, subject to
timeouts</td>
<td><a
target="_blank" rel="noopener" href="https://colab.research.google.com/notebooks/gpu.ipynb">Follow the
Google Colab Guide</a></td>
</tr>
<tr class="even">
<td>Use your own</td>
<td>Medium</td>
<td>Run everything locally on your own machine</td>
<td>GPUs aren't free, require upfront cost</td>
<td>Follow the <a
target="_blank" rel="noopener" href="https://pytorch.org/get-started/locally/">PyTorch installation
guidelines</a></td>
</tr>
<tr class="odd">
<td>Cloud computing (AWS, GCP, Azure)</td>
<td>Medium-Hard</td>
<td>Small upfront cost, access to almost infinite compute</td>
<td>Can get expensive if running continually, takes some time ot setup
right</td>
<td>Follow the <a
target="_blank" rel="noopener" href="https://pytorch.org/get-started/cloud-partners/">PyTorch
installation guidelines</a></td>
</tr>
</tbody>
</table>
<p>There are more options for using GPUs but the above three will
suffice for now.</p>
<p>Personally, I use a combination of Google Colab and my own personal
computer for small scale experiments (and creating this course) and go
to cloud resources when I need more compute power.</p>
<blockquote>
<p><strong>Resource:</strong> If you're looking to purchase a GPU of
your own but not sure what to get, <a
target="_blank" rel="noopener" href="https://timdettmers.com/2020/09/07/which-gpu-for-deep-learning/">Tim
Dettmers has an excellent guide</a>.</p>
</blockquote>
<p>To check if you've got access to a Nvidia GPU, you can run
<code>!nvidia-smi</code> where the <code>!</code> (also called bang)
means "run this on the command line".</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!nvidia-smi</span><br></pre></td></tr></table></figure>
<pre><code>Thu Feb 10 02:09:18 2022       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 460.32.03    Driver Version: 460.32.03    CUDA Version: 11.2     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  Tesla P100-PCIE...  Off  | 00000000:00:04.0 Off |                    0 |
| N/A   36C    P0    28W / 250W |      0MiB / 16280MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+</code></pre>
<p>If you don't have a Nvidia GPU accessible, the above will output
something like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIDIA-SMI has failed because it couldn&#x27;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.</span><br></pre></td></tr></table></figure>
<p>In that case, go back up and follow the install steps.</p>
<p>If you do have a GPU, the line above will output something like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Wed Jan 19 22:09:08 2022       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 495.46       Driver Version: 460.32.03    CUDA Version: 11.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla P100-PCIE...  Off  | 00000000:00:04.0 Off |                    0 |</span><br><span class="line">| N/A   35C    P0    27W / 250W |      0MiB / 16280MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="getting-pytorch-to-run-on-the-gpu">2. Getting PyTorch to run on
the GPU</h3>
<p>Once you've got a GPU ready to access, the next step is getting
PyTorch to use for storing data (tensors) and computing on data
(performing operations on tensors).</p>
<p>To do so, you can use the <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/cuda.html"><code>torch.cuda</code></a>
package.</p>
<p>Rather than talk about it, let's try it out.</p>
<p>You can test if PyTorch has access to a GPU using <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.cuda.is_available.html#torch.cuda.is_available"><code>torch.cuda.is_available()</code></a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check for GPU</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>
<pre><code>True</code></pre>
<p>If the above outputs <code>True</code>, PyTorch can see and use the
GPU, if it outputs <code>False</code>, it can't see the GPU and in that
case, you'll have to go back through the installation steps.</p>
<p>Now, let's say you wanted to setup your code so it ran on CPU
<em>or</em> the GPU if it was available.</p>
<p>That way, if you or someone decides to run your code, it'll work
regardless of the computing device they're using.</p>
<p>Let's create a <code>device</code> variable to store what kind of
device is available.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set device type</span></span><br><span class="line">device = <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line">device</span><br></pre></td></tr></table></figure>
<pre><code>&#39;cuda&#39;</code></pre>
<p>If the above output <code>"cuda"</code> it means we can set all of
our PyTorch code to use the available CUDA device (a GPU) and if it
output <code>"cpu"</code>, our PyTorch code will stick with the CPU.</p>
<blockquote>
<p><strong>Note:</strong> In PyTorch, it's best practice to write <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/master/notes/cuda.html#device-agnostic-code"><strong>device
agnostic code</strong></a>. This means code that'll run on CPU (always
available) or GPU (if available).</p>
</blockquote>
<p>If you want to do faster computing you can use a GPU but if you want
to do <em>much</em> faster computing, you can use multiple GPUs.</p>
<p>You can count the number of GPUs PyTorch has access to using <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.cuda.device_count.html#torch.cuda.device_count"><code>torch.cuda.device_count()</code></a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count number of devices</span></span><br><span class="line">torch.cuda.device_count()</span><br></pre></td></tr></table></figure>
<pre><code>1</code></pre>
<p>Knowing the number of GPUs PyTorch has access to is helpful incase
you wanted to run a specific process on one GPU and another process on
another (PyTorch also has features to let you run a process across
<em>all</em> GPUs).</p>
<h3 id="putting-tensors-and-models-on-the-gpu">3. Putting tensors (and
models) on the GPU</h3>
<p>You can put tensors (and models, we'll see this later) on a specific
device by calling <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.Tensor.to.html"><code>to(device)</code></a>
on them. Where <code>device</code> is the target device you'd like the
tensor (or model) to go to.</p>
<p>Why do this?</p>
<p>GPUs offer far faster numerical computing than CPUs do and if a GPU
isn't available, because of our <strong>device agnostic code</strong>
(see above), it'll run on the CPU.</p>
<blockquote>
<p><strong>Note:</strong> Putting a tensor on GPU using
<code>to(device)</code> (e.g. <code>some_tensor.to(device)</code>)
returns a copy of that tensor, e.g. the same tensor will be on CPU and
GPU. To overwrite tensors, reassign them:</p>
<p><code>some_tensor = some_tensor.to(device)</code></p>
</blockquote>
<p>Let's try creating a tensor and putting it on the GPU (if it's
available).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create tensor (default on CPU)</span></span><br><span class="line">tensor = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tensor not on GPU</span></span><br><span class="line"><span class="built_in">print</span>(tensor, tensor.device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Move tensor to GPU (if available)</span></span><br><span class="line">tensor_on_gpu = tensor.to(device)</span><br><span class="line">tensor_on_gpu</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 2, 3]) cpu





tensor([1, 2, 3], device=&#39;cuda:0&#39;)</code></pre>
<p>If you have a GPU available, the above code will output something
like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([1, 2, 3]) cpu</span><br><span class="line">tensor([1, 2, 3], device=&#x27;cuda:0&#x27;)</span><br></pre></td></tr></table></figure>
<p>Notice the second tensor has <code>device='cuda:0'</code>, this means
it's stored on the 0th GPU available (GPUs are 0 indexed, if two GPUs
were available, they'd be <code>'cuda:0'</code> and
<code>'cuda:1'</code> respectively, up to <code>'cuda:n'</code>).</p>
<h3 id="moving-tensors-back-to-the-cpu">4. Moving tensors back to the
CPU</h3>
<p>What if we wanted to move the tensor back to CPU?</p>
<p>For example, you'll want to do this if you want to interact with your
tensors with NumPy (NumPy does not leverage the GPU).</p>
<p>Let's try using the <a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.Tensor.numpy.html"><code>torch.Tensor.numpy()</code></a>
method on our <code>tensor_on_gpu</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If tensor is on GPU, can&#x27;t transform it to NumPy (this will error)</span></span><br><span class="line">tensor_on_gpu.numpy()</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-75-53175578f49e&gt; in &lt;module&gt;()
      1 # If tensor is on GPU, can&#39;t transform it to NumPy (this will error)
----&gt; 2 tensor_on_gpu.numpy()


TypeError: can&#39;t convert cuda:0 device type tensor to numpy. Use Tensor.cpu() to copy the tensor to host memory first.</code></pre>
<p>Instead, to get a tensor back to CPU and usable with NumPy we can use
<a
target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.Tensor.cpu.html"><code>Tensor.cpu()</code></a>.</p>
<p>This copies the tensor to CPU memory so it's usable with CPUs.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Instead, copy the tensor back to cpu</span></span><br><span class="line">tensor_back_on_cpu = tensor_on_gpu.cpu().numpy()</span><br><span class="line">tensor_back_on_cpu</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3])</code></pre>
<p>The above returns a copy of the GPU tensor in CPU memory so the
original tensor is still on GPU.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor_on_gpu</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1, 2, 3], device=&#39;cuda:0&#39;)</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Confetti-lxy">Confetti-lxy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.confetti-lxy.com/2023/05/12/pytorch-learn-00/">http://blog.confetti-lxy.com/2023/05/12/pytorch-learn-00/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/torch/">torch</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover-11.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/12/pytorch-learn-01/" title="pytorch-learn-01"><img class="cover" src="/img/cover/cover-14.jpeg" onerror="onerror=null;src='/img/common/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">pytorch-learn-01</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/29/plcs/" title="plcs"><img class="cover" src="/img/cover/cover-02.png" onerror="onerror=null;src='/img/common/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">plcs</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/05/12/pytorch-learn-01/" title="pytorch-learn-01"><img class="cover" src="/img/cover/cover-14.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-12</div><div class="title">pytorch-learn-01</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/common/avatar.png" onerror="this.onerror=null;this.src='/img/common/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Confetti-lxy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Confetti-lxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Confetti-lxy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3038454387@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">总要记些什么证明我来过</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#pytorch-fundamentals"><span class="toc-number">1.</span> <span class="toc-text">00. PyTorch Fundamentals</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#what-is-pytorch"><span class="toc-number">1.1.</span> <span class="toc-text">What is PyTorch?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#what-can-pytorch-be-used-for"><span class="toc-number">1.2.</span> <span class="toc-text">What can PyTorch be used for?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#who-uses-pytorch"><span class="toc-number">1.3.</span> <span class="toc-text">Who uses PyTorch?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#why-use-pytorch"><span class="toc-number">1.4.</span> <span class="toc-text">Why use PyTorch?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#what-were-going-to-cover-in-this-module"><span class="toc-number">1.5.</span> <span class="toc-text">What we&#39;re going to
cover in this module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#where-can-can-you-get-help"><span class="toc-number">1.6.</span> <span class="toc-text">Where can can you get help?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#importing-pytorch"><span class="toc-number">1.7.</span> <span class="toc-text">Importing PyTorch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction-to-tensors"><span class="toc-number">1.8.</span> <span class="toc-text">Introduction to tensors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#creating-tensors"><span class="toc-number">1.8.1.</span> <span class="toc-text">Creating tensors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#random-tensors"><span class="toc-number">1.8.2.</span> <span class="toc-text">Random tensors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zeros-and-ones"><span class="toc-number">1.8.3.</span> <span class="toc-text">Zeros and ones</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#creating-a-range-and-tensors-like"><span class="toc-number">1.8.4.</span> <span class="toc-text">Creating a range and tensors
like</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tensor-datatypes"><span class="toc-number">1.8.5.</span> <span class="toc-text">Tensor datatypes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getting-information-from-tensors"><span class="toc-number">1.9.</span> <span class="toc-text">Getting information from
tensors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#manipulating-tensors-tensor-operations"><span class="toc-number">1.10.</span> <span class="toc-text">Manipulating tensors
(tensor operations)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-operations"><span class="toc-number">1.10.1.</span> <span class="toc-text">Basic operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#matrix-multiplication-is-all-you-need"><span class="toc-number">1.10.2.</span> <span class="toc-text">Matrix multiplication (is
all you need)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#one-of-the-most-common-errors-in-deep-learning-shape-errors"><span class="toc-number">1.11.</span> <span class="toc-text">One
of the most common errors in deep learning (shape errors)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#finding-the-min-max-mean-sum-etc-aggregation"><span class="toc-number">1.11.1.</span> <span class="toc-text">Finding the min,
max, mean, sum, etc (aggregation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#positional-minmax"><span class="toc-number">1.11.2.</span> <span class="toc-text">Positional min&#x2F;max</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#change-tensor-datatype"><span class="toc-number">1.11.3.</span> <span class="toc-text">Change tensor datatype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reshaping-stacking-squeezing-and-unsqueezing"><span class="toc-number">1.11.4.</span> <span class="toc-text">Reshaping,
stacking, squeezing and unsqueezing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#indexing-selecting-data-from-tensors"><span class="toc-number">1.12.</span> <span class="toc-text">Indexing (selecting data
from tensors)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pytorch-tensors-numpy"><span class="toc-number">1.13.</span> <span class="toc-text">PyTorch tensors &amp; NumPy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reproducibility-trying-to-take-the-random-out-of-random"><span class="toc-number">1.14.</span> <span class="toc-text">Reproducibility
(trying to take the random out of random)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#running-tensors-on-gpus-and-making-faster-computations"><span class="toc-number">1.15.</span> <span class="toc-text">Running
tensors on GPUs (and making faster computations)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getting-a-gpu"><span class="toc-number">1.15.1.</span> <span class="toc-text">1. Getting a GPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getting-pytorch-to-run-on-the-gpu"><span class="toc-number">1.15.2.</span> <span class="toc-text">2. Getting PyTorch to run on
the GPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putting-tensors-and-models-on-the-gpu"><span class="toc-number">1.15.3.</span> <span class="toc-text">3. Putting tensors (and
models) on the GPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#moving-tensors-back-to-the-cpu"><span class="toc-number">1.15.4.</span> <span class="toc-text">4. Moving tensors back to the
CPU</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/12/pytorch-learn-01/" title="pytorch-learn-01"><img src="/img/cover/cover-14.jpeg" onerror="this.onerror=null;this.src='/img/common/404.jpg'" alt="pytorch-learn-01"/></a><div class="content"><a class="title" href="/2023/05/12/pytorch-learn-01/" title="pytorch-learn-01">pytorch-learn-01</a><time datetime="2023-05-12T15:25:52.000Z" title="Created 2023-05-12 23:25:52">2023-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/12/pytorch-learn-00/" title="pytorch-learn-00"><img src="/img/cover/cover-11.jpeg" onerror="this.onerror=null;this.src='/img/common/404.jpg'" alt="pytorch-learn-00"/></a><div class="content"><a class="title" href="/2023/05/12/pytorch-learn-00/" title="pytorch-learn-00">pytorch-learn-00</a><time datetime="2023-05-12T15:10:52.000Z" title="Created 2023-05-12 23:10:52">2023-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/29/plcs/" title="plcs"><img src="/img/cover/cover-02.png" onerror="this.onerror=null;this.src='/img/common/404.jpg'" alt="plcs"/></a><div class="content"><a class="title" href="/2023/04/29/plcs/" title="plcs">plcs</a><time datetime="2023-04-29T15:53:13.000Z" title="Created 2023-04-29 23:53:13">2023-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/28/pstree/" title="pstree"><img src="/img/cover/cover-09.jpeg" onerror="this.onerror=null;this.src='/img/common/404.jpg'" alt="pstree"/></a><div class="content"><a class="title" href="/2023/04/28/pstree/" title="pstree">pstree</a><time datetime="2023-04-28T15:10:48.000Z" title="Created 2023-04-28 23:10:48">2023-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/28/Algorithm-Design-and-Analysis-03/" title="Algorithm Design and Analysis-03"><img src="/img/cover/cover-01.png" onerror="this.onerror=null;this.src='/img/common/404.jpg'" alt="Algorithm Design and Analysis-03"/></a><div class="content"><a class="title" href="/2023/04/28/Algorithm-Design-and-Analysis-03/" title="Algorithm Design and Analysis-03">Algorithm Design and Analysis-03</a><time datetime="2023-04-28T04:09:04.000Z" title="Created 2023-04-28 12:09:04">2023-04-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/PL/PL-1.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Confetti-lxy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世界很大,我想去看看</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>